clc;
clear;
clear;

%------------------------------------------------------程序说明--------------------------------------------------------------
%本程序首先实现了对内边缘的定位，基于对外边缘的边缘初步分割
tt=1;
for i=10:10
   
  tic
    ii=mat2str(i);
    filename=[ii,'.jpg'];
    eye=imread(filename);
%%
window_size=9;
delta_T=8;
delta_iris=6;
p=3;
%%------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%%---------------------------------------------------------------------------------------1.预处理-------------------------------------------------------------------------------------
%%------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

%---------------------------------------------1.1如果图像为彩色类型，将其改为灰度图---------------------------------------------

if ndims(eye)==3
eye=rgb2gray(eye);
end
[M1,N1]=size(eye);
%---------------------------------------------1.2对图像进行下采样--------------------------------------------------------------
if M1>=500
    eye1=imresize(eye,0.8);
    
%     eye1=imresize(eye,0.5);
else  
    eye1=imresize(eye,0.4);    
end
eye2=eye1;
%---------------------------------------------1.3图像归一化--------------------------------------------------------------------
eye1=double(eye1)/256;
%%------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%%---------------------------------------------------------------------------------------1.预处理-------------------------------------------------------------------------------------
%%------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%%2.虹膜内边缘检测
%---------------------------------------------2.1将图像划分为K*l个大小为window_size×window_size窗口------------------------------------------------

[M,N]=size(eye1);
k=floor(M/window_size);
l=floor(N/window_size);
%---------------------------------------------2.2计算每个窗口(一共k*l个窗口)的灰度均值---------------------------------------------
A=cell(k*l,1);%元胞数组A存放每个窗口的灰度均值
B=zeros(k*l,1);
x=1;

for i=1:k
    y=1;
   for j=1:l       
    A{(i-1)*l+j}=eye1(x:x+window_size-1,y:y+window_size-1);
    B((i-1)*l+j)=sum(sum(A{(i-1)*l+j}))*k*l/M/N;
    y=y+window_size;
    end
    x=x+window_size;
end
T=min(B);%将最小灰度均值作为二值变换阈值
eye_bw=im2bw(eye1,T+delta_T/256);%二值化提取瞳孔
%---------------------------------------------2.3找出最大面积的区域设置为瞳孔区域-----------------------------------------------

eye_blur = medfilt2(eye_bw,[7 7],'symmetric');%%除去二值化图像中的点状噪声
eye_blur=1-eye_blur;%二值反变换方面后续连通区域标记
[L, num] = bwlabel(eye_blur, 4); % 区域标记，一般此时只剩两个区域，一个区域为瞳孔部分，另一可能存在的区域为睫毛部分
stats = regionprops(L, 'Basic'); 
Bd = cat(1,stats.BoundingBox);%将struct:stats的BoundingBox区域方框中内容转化为矩阵
Ar=cat(1,stats.Area);%将struct:stats的Area区域面积中内容转化为矩阵

%---------------------------------------------2.4找出最大面积的区域设置为瞳孔区域,并提取粗定位的瞳孔------------------------------
mx=max(Ar);
[j,s]=find(Ar==mx);
cirp=Bd(j,:);
Rp=round((cirp(1,3)+cirp(1,4))/4);%瞳孔圆心、半径粗定位
xp=round(Rp+cirp(1,2));
yp=round(Rp+cirp(1,1));
%canny算子提取边缘

%%除去中心白点，减少运算量

for m=xp-Rp:xp+Rp
    for  n=yp-Rp:yp+Rp
       R2=(m-xp)^2+(n-yp)^2;
       if R2<=Rp^2*0.9
           eye1(m,n)=0;
       end
    end
end
edge_w=edge(eye1,'canny');
edge_pupil=zeros(M,N);
for x=1:M
    for y=1:N
if (x>xp-Rp-3&&x<xp+Rp+3)&&(y>yp-Rp-3&&y<yp+Rp+3)
    edge_pupil(x,y)=edge_w(x,y);
end
    end
end

%---------------------------------------------2.5根据粗定位的瞳孔对提取的瞳孔边缘进行霍夫变换-----------------

mean_circle=houghiris(edge_pupil,0.2,0.1,Rp-4,Rp+4,0.9,xp,yp);
A=edge_w;

[M,N]=size(A);
%%-------------------------------------------去除噪声区域,根据统计，最小值为36，最大值为50
r_max=24;
r_min=9;

%区域1
if r_max-(r_max-r_min)*2/3<mean_circle(3)<r_max
    delta_y=15;
    delta_r=34;
else
    delta_y=25;
    delta_r=70;
end

A(:,mean_circle(2)-delta_y:mean_circle(2)+delta_y)=0;

%区域2,3
for i=1:M
    for j=1:N
        if (i-(mean_circle(1)+2*mean_circle(3)))^2+(j-mean_circle(2))^2>(mean_circle(3)*2+delta_r)^2
            A(i,j)=0;
        end
        
        if (i-(mean_circle(1)-2*mean_circle(3)))^2+(j-mean_circle(2))^2>(mean_circle(3)*2+delta_r)^2
            A(i,j)=0;
        end
    end
end


%提取左半部分与右半部分
A_L=A(:,1:mean_circle(2));
A_R=A(:,mean_circle(2)+1:N);
subplot(1,3,1),imshow(A_L),title('左半部分初步分割结果')
subplot(1,3,2),imshow(A_R),title('右半部分初步分割结果')
subplot(1,3,3),imshow(A),title('初步分割结果')
% %虹膜外边缘提取
% %左边缘
% [x,y]=find(A_L==1);
% T=size(x);
% 
% % for i=1:T
% %     A_L(x(i),y(i))=0;
% % end
% 
% L=bwlabel(A_L,8);
% stats = regionprops(A_L, 'basic');
% % imshow(A_L);
% LS=size(stats);
% DATA=zeros(LS(1),4);
% 
% %寻找连通域顶部的值来确定线段计点起点
% for i=1:LS
% DATA(i,:)=stats(i,:).BoundingBox;
% end
% 
% edges=zeros(M,N,LS(1));
% %设计模板提取实际外边缘
% for k=1:LS
%     K=0;
%     i=round(DATA(k,2));
%     j=round(DATA(k,1));
%     while(A_L(i+1,j-1)==1||A_L(i+1,j)==1||A_L(i+1,j+1)==1||A_L(i,j-1)==1)
%         K=K+1;
%         DATA(k,5)=K;
%         if(A_L(i+1,j-1)==1)
%             i=i+1;
%             j=j-1;
%             edges(i,j,k)=1;
%             continue;
%             
%         elseif(A_L(i+1,j)==1)
%             i=i+1;
%             edges(i,j,k)=1;
%             %j=j;
%             continue;
%             
%         elseif(A_L(i+1,j+1)==1)
%             i=i+1;
%             j=j+1;
%             edges(i,j,k)=1;
%             continue;
%         elseif(A_L(i,j-1)==1)
%             %i=i;
%             j=j-1;
%             edges(i,j,k)=1;
%             continue;
%         end
%         
%     end
% end
end
toc


