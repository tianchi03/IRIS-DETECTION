clc;
clear;
clear;

%------------------------------------------------------参数说明--------------------------------------------------------------
%window_size：最小灰度值选取阈值时窗口大小，当eye图宽度在[350,450]之间时，我们取window_size=7。
%delta_T:瞳孔部分二值变换时变换阈值增量。经试验，我们取delta_T=8。则二值变换时im2bw(img,T+delta_T/256),T为求得的最小灰度值。                                                                           
%delta_iris：外边缘粗定位时判断圆周时的量化补偿大小
%p：虹膜外边缘圆心与内边缘圆心允许偏离半径
%------------------------------------------------------说明结束--------------------------------------------------------------
%------------------------------------------------------变量说明--------------------------------------------------------------
%eye:原图像
%eye1：下采样0.4倍的图像
%T：最小灰度值计算而得的二值变换阈值
%eye_bw：二值变换后的图像
%eye_blur:使用中值滤波去除噪声后的eye_bw
%edge_pupil:提取出的瞳孔边缘图像
%edge_iris:提取得来的虹膜边缘图像
%pspace：外边缘粗定位时的圆周空间
%mean_circle:定位得来的虹膜内边缘
%iris_circle:定位得来的虹膜外边缘
%------------------------------------------------------说明结束--------------------------------------------------------------
tt=1;
for i=10:10
   
  tic
    ii=mat2str(i);
    filename=[ii,'.jpg'];
    eye=imread(filename);
%%
window_size=9;
delta_T=8;
delta_iris=6;
p=3;
%%------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%%---------------------------------------------------------------------------------------1.预处理-------------------------------------------------------------------------------------
%%------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

%---------------------------------------------1.1如果图像为彩色类型，将其改为灰度图---------------------------------------------

if ndims(eye)==3
eye=rgb2gray(eye);
end
[M1,N1]=size(eye);
%---------------------------------------------1.2对图像进行下采样--------------------------------------------------------------
if M1>=500
    eye1=imresize(eye,0.8);
    
%     eye1=imresize(eye,0.5);
else  
    eye1=imresize(eye,0.4);    
end
eye2=eye1;
%---------------------------------------------1.3图像归一化--------------------------------------------------------------------
eye1=double(eye1)/256;
%%------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%%---------------------------------------------------------------------------------------1.预处理-------------------------------------------------------------------------------------
%%------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%%2.虹膜内边缘检测
%---------------------------------------------2.1将图像划分为K*l个大小为window_size×window_size窗口------------------------------------------------

[M,N]=size(eye1);
k=floor(M/window_size);
l=floor(N/window_size);
%---------------------------------------------2.2计算每个窗口(一共k*l个窗口)的灰度均值---------------------------------------------
A=cell(k*l,1);%元胞数组A存放每个窗口的灰度均值
B=zeros(k*l,1);
x=1;

for i=1:k
    y=1;
   for j=1:l       
    A{(i-1)*l+j}=eye1(x:x+window_size-1,y:y+window_size-1);
    B((i-1)*l+j)=sum(sum(A{(i-1)*l+j}))*k*l/M/N;
    y=y+window_size;
    end
    x=x+window_size;
end
T=min(B);%将最小灰度均值作为二值变换阈值
eye_bw=im2bw(eye1,T+delta_T/256);%二值化提取瞳孔
%---------------------------------------------2.3找出最大面积的区域设置为瞳孔区域-----------------------------------------------

eye_blur = medfilt2(eye_bw,[7 7],'symmetric');%%除去二值化图像中的点状噪声
eye_blur=1-eye_blur;%二值反变换方面后续连通区域标记
[L, num] = bwlabel(eye_blur, 4); % 区域标记，一般此时只剩两个区域，一个区域为瞳孔部分，另一可能存在的区域为睫毛部分
stats = regionprops(L, 'Basic'); 
Bd = cat(1,stats.BoundingBox);%将struct:stats的BoundingBox区域方框中内容转化为矩阵
Ar=cat(1,stats.Area);%将struct:stats的Area区域面积中内容转化为矩阵

%---------------------------------------------2.4找出最大面积的区域设置为瞳孔区域,并提取粗定位的瞳孔------------------------------
mx=max(Ar);
[j,s]=find(Ar==mx);
cirp=Bd(j,:);
Rp=round((cirp(1,3)+cirp(1,4))/4);%瞳孔圆心、半径粗定位
xp=round(Rp+cirp(1,2));
yp=round(Rp+cirp(1,1));
%canny算子提取边缘

%%除去中心白点，减少运算量

for m=xp-Rp:xp+Rp
    for  n=yp-Rp:yp+Rp
       R2=(m-xp)^2+(n-yp)^2;
       if R2<=Rp^2*0.9
           eye1(m,n)=0;
       end
    end
end
edge_w=edge(eye1,'canny');
edge_pupil=zeros(M,N);
for x=1:M
    for y=1:N
if (x>xp-Rp-3&&x<xp+Rp+3)&&(y>yp-Rp-3&&y<yp+Rp+3)
    edge_pupil(x,y)=edge_w(x,y);
end
    end
end

%---------------------------------------------2.5根据粗定位的瞳孔对提取的瞳孔边缘进行霍夫变换-----------------

mean_circle=houghiris(edge_pupil,0.2,0.1,Rp-4,Rp+4,0.9,xp,yp);


%%------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%%-------------------------------------------------------------------------------------------3.虹膜内边缘定位--------------------------------------------------------------------------
%%------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

%-------------------3.1直方图均衡化并提取边缘（canny系数为0.4，保留虹膜边缘并有效除去部分纹理边缘）-------------

eye1=histeq(eye1,32);
edge_iris=edge(eye1,'canny');
%----------------------------------------------3.2去除圆心部分----------------------------------------------
for x=1:M
    for y=1:N
if (x>xp-Rp-6&&x<xp+Rp+6)&&(y>yp-Rp-6&&y<yp+Rp+6)
    edge_iris(x,y)=0;
end
    end
end
%-------------------------------------3.3基于量化补偿的虹膜外边缘粗定位--------------------------------------
% 
r_min=35;%粗定位r初始值
r_max=N;%粗定位r最大值
x0=mean_circle(2,1);
y0=mean_circle(1,1);
step_r=3;%r变换步长
size_r=round((r_max-r_min)/step_r);
pspace=zeros(p*2+1,p*2+1,size_r);
[rows,cols]=find(edge_iris);
count=size(rows);
for i=1:(p*2+1)
    for j=1:(p*2+1)
        for r=1:size_r
            for k=1:count
                diff=(cols(k)-x0+p+1-i)^2+(rows(k)-y0+p+1-j)^2-(r_min+step_r*r)^2;%最小二乘法判断圆周
                if abs(diff)<delta_iris
                    pspace(i,j,r)=pspace(i,j,r)+1;%%如果满足差值abs(diff)小于规定的delta_iris，我们认为其在圆周上
                end
            end
        end
    end
end

dot_sum=sum(sum(pspace));
dot_r=max(dot_sum);
j=1;
iris_rough=find(dot_sum==dot_r);
iris_r=mean(iris_rough(:,1))*step_r+r_min;
% 
% %test
% 
% 

%---------------------------------------------------------------------------3.4虹膜外边缘细定位-------------------------------------------------------------------------------------------

%iris=houghcircle(edge_iris,0.1,0.1,35,70,0.2);
iris=houghiris(edge_iris,1,0.2,iris_r-1,iris_r+4,0.7,y0,x0);


%%----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%%------------------------------------------------------4.显示结果------------------------------------------------------------------------------------------------------------------------
%%----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
figure,imshow(eye2);
plot_circle(iris);
plot_pupil(mean_circle);
%%提取虹膜
RR(tt)=mean_circle(3);

tt=tt+1;
toc
end

